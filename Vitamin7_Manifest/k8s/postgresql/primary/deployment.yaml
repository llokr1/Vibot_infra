apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql-primary
  namespace: postgresql-primary
  labels:
    app: postgresql-primary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgresql-primary
  template:
    metadata:
      labels:
        app: postgresql-primary
    spec:
      # AZ 설정: primary는 zone-a에 배포
      # PVC의 volumeBindingMode가 WaitForFirstConsumer이므로
      # Pod가 먼저 스케줄링되고, 그 노드의 zone에 PVC가 바인딩됨
      nodeSelector:
        topology.kubernetes.io/zone: "kr-central-2-a"
      initContainers:
        - name: copy-replication-config
          image: postgres:16-alpine
          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "Copying replication configuration files..."
              
              # PostgreSQL 데이터 디렉토리 확인
              PGDATA_DIR="/var/lib/postgresql/data/pgdata"
              
              # 데이터 디렉토리가 없으면 생성 (초기 실행 시)
              mkdir -p "${PGDATA_DIR}"
              
              # postgresql.conf 설정 적용
              if [ -f "/config/postgresql.conf" ]; then
                echo "Applying postgresql.conf replication settings..."
                # 기존 postgresql.conf가 있으면 백업
                if [ -f "${PGDATA_DIR}/postgresql.conf" ]; then
                  cp "${PGDATA_DIR}/postgresql.conf" "${PGDATA_DIR}/postgresql.conf.backup"
                  # ConfigMap의 설정을 postgresql.conf에 직접 추가 (include 방식은 복잡하므로 직접 추가)
                  echo "" >> "${PGDATA_DIR}/postgresql.conf"
                  echo "# Replication settings from ConfigMap" >> "${PGDATA_DIR}/postgresql.conf"
                  cat /config/postgresql.conf >> "${PGDATA_DIR}/postgresql.conf"
                else
                  # 초기 실행 시: ConfigMap의 설정을 직접 사용
                  cp /config/postgresql.conf "${PGDATA_DIR}/postgresql.conf"
                fi
              fi
              
              # pg_hba.conf 설정 적용
              if [ -f "/config/pg_hba.conf" ]; then
                echo "Applying pg_hba.conf replication settings..."
                # 기존 pg_hba.conf가 있으면 백업
                if [ -f "${PGDATA_DIR}/pg_hba.conf" ]; then
                  cp "${PGDATA_DIR}/pg_hba.conf" "${PGDATA_DIR}/pg_hba.conf.backup"
                  # 기존 파일에서 문제가 되는 md5 라인 제거 (정상 환경과 동일하게)
                  # host all all 0.0.0.0/0 md5 라인 제거 (여러 번 있을 수 있으므로 모두 제거)
                  sed -i '/^host[[:space:]]*all[[:space:]]*all[[:space:]]*0\.0\.0\.0\/0[[:space:]]*md5$/d' "${PGDATA_DIR}/pg_hba.conf.backup" || true
                  # 중복된 trust 라인도 정리 (기본 PostgreSQL 설정과 ConfigMap 설정이 중복될 수 있음)
                  # ConfigMap의 설정으로 완전히 교체 (정상 환경과 동일하게)
                  {
                    # 기본 trust 설정 (localhost만)
                    echo "local   all             all                                     trust"
                    echo "host    all             all             127.0.0.1/32            trust"
                    echo "host    all             all             ::1/128                 trust"
                    echo "local   replication     all                                     trust"
                    echo "host    replication     all             127.0.0.1/32            trust"
                    echo "host    replication     all             ::1/128                 trust"
                    # ConfigMap의 설정 추가
                    echo ""
                    echo "# Replication settings from ConfigMap"
                    cat /config/pg_hba.conf
                  } > "${PGDATA_DIR}/pg_hba.conf"
                else
                  # 초기 실행 시: ConfigMap의 설정을 직접 사용
                  cp /config/pg_hba.conf "${PGDATA_DIR}/pg_hba.conf"
                fi
              fi
              
              echo "Replication configuration files copied successfully"
          volumeMounts:
            - name: postgresql-storage
              mountPath: /var/lib/postgresql/data
            - name: replication-config
              mountPath: /config
              readOnly: true
      containers:
        - name: postgresql
          # PostgreSQL 16 공식 이미지
          image: postgres:16-alpine
          imagePullPolicy: IfNotPresent
          ports:
            - name: postgresql
              containerPort: 5432
              protocol: TCP
          env:
            # PostgreSQL 데이터베이스 이름
            - name: POSTGRES_DB
              valueFrom:
                configMapKeyRef:
                  name: postgresql-config
                  key: POSTGRES_DB
            # PostgreSQL 사용자명
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgresql-credentials
                  key: username
            # PostgreSQL 비밀번호
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgresql-credentials
                  key: password
            # PostgreSQL 데이터 디렉토리
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
            # Replication 설정
            # 주의: postgresql-credentials Secret에 'replication-password' 키가 반드시 있어야 합니다.
            # Secret 생성 예시:
            # kubectl create secret generic postgresql-credentials \
            #   --from-literal=username=postgres \
            #   --from-literal=password=your-password \
            #   --from-literal=replication-password=your-replication-password \
            #   -n postgresql-primary
            - name: POSTGRES_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgresql-credentials
                  key: replication-password
            # WAL 및 Replication 설정 (초기 DB 생성 시에만 적용)
            - name: POSTGRES_INITDB_ARGS
              value: "-c wal_level=replica -c max_wal_senders=3 -c max_replication_slots=3 -c wal_keep_size=1024MB -c hot_standby=on"
          lifecycle:
            postStart:
              exec:
                command:
                  - /bin/sh
                  - -c
                  - |
                    set -e
                    echo "Waiting for PostgreSQL to be ready for replication setup..."
                    # PostgreSQL이 완전히 시작될 때까지 대기
                    until pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}; do
                      sleep 2
                    done
                    
                    # 추가 대기 (PostgreSQL이 완전히 초기화될 때까지)
                    sleep 5
                    
                    echo "Setting up replication user and slot..."
                    psql -v ON_ERROR_STOP=1 -U ${POSTGRES_USER} -d ${POSTGRES_DB} <<EOF
                    DO \$\$
                    BEGIN
                        IF NOT EXISTS (SELECT FROM pg_catalog.pg_user WHERE usename = 'replicator') THEN
                            CREATE USER replicator WITH REPLICATION PASSWORD '${POSTGRES_REPLICATION_PASSWORD}';
                            RAISE NOTICE 'Replication user created';
                        ELSE
                            RAISE NOTICE 'Replication user already exists';
                        END IF;
                    END
                    \$\$;
                    
                    SELECT pg_create_physical_replication_slot('backup_slot', true, false)
                    WHERE NOT EXISTS (
                        SELECT 1 FROM pg_replication_slots WHERE slot_name = 'backup_slot'
                    );
                    EOF
                    echo "Replication setup completed"
          volumeMounts:
            - name: postgresql-storage
              mountPath: /var/lib/postgresql/data
          # 리소스 제한 (메모리 엄격 관리, CPU는 넉넉하게)
          # PostgreSQL shared_buffers, work_mem 등 고려
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"  # PostgreSQL 최소 안전 메모리 (shared_buffers 128Mi + 오버헤드)
              cpu: "2000m"     # CPU는 넉넉하게
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U $(POSTGRES_USER) -d $(POSTGRES_DB)
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - pg_isready -U $(POSTGRES_USER) -d $(POSTGRES_DB)
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: postgresql-storage
          persistentVolumeClaim:
            claimName: postgresql-pvc
        - name: replication-config
          configMap:
            name: postgresql-replication-config

